<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindle Notes Parser - Web App</title>
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'none';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    
    <style>
/* 
 * Kindle Notes Parser - Styles
 * Modern, responsive CSS for the web application
 */

/* 
 * Kindle Notes Parser - Styles
 * Modern, responsive CSS with light/dark theme support
 */

/* CSS Custom Properties for Theme System */
:root {
    /* Light theme (default) */
    --bg-primary: #f8f9fa;
    --bg-secondary: #ffffff;
    --bg-tertiary: #ecf0f1;
    --text-primary: #333333;
    --text-secondary: #7f8c8d;
    --text-tertiary: #95a5a6;
    --accent-primary: #3498db;
    --accent-secondary: #2980b9;
    --accent-success: #27ae60;
    --accent-warning: #f39c12;
    --accent-danger: #e74c3c;
    --border-primary: #e0e0e0;
    --border-secondary: #d0d0d0;
    --shadow-light: rgba(0,0,0,0.1);
    --shadow-medium: rgba(0,0,0,0.15);
    --overlay: rgba(0,0,0,0.05);
}

/* Light theme - manual selection */
:root[data-theme="light"] {
    --bg-primary: #f8f9fa;
    --bg-secondary: #ffffff;
    --bg-tertiary: #f1f3f5;
    --text-primary: #2c3e50;
    --text-secondary: #5a6c7d;
    --text-tertiary: #7f8c8d;
    --accent-primary: #007bff;
    --accent-secondary: #0056b3;
    --accent-success: #28a745;
    --accent-warning: #ffc107;
    --accent-danger: #dc3545;
    --border-primary: #dee2e6;
    --border-secondary: #ced4da;
    --shadow-light: rgba(0,0,0,0.1);
    --shadow-medium: rgba(0,0,0,0.15);
    --overlay: rgba(0,0,0,0.05);
}

/* Dark theme - manual selection */
:root[data-theme="dark"] {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: #404040;
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --text-tertiary: #888888;
    --accent-primary: #4a9eff;
    --accent-secondary: #357abd;
    --accent-success: #2ecc71;
    --accent-warning: #f1c40f;
    --accent-danger: #e67e22;
    --border-primary: #404040;
    --border-secondary: #555555;
    --shadow-light: rgba(0,0,0,0.3);
    --shadow-medium: rgba(0,0,0,0.4);
    --overlay: rgba(255,255,255,0.05);
}

/* Auto theme detection */
@media (prefers-color-scheme: dark) {
    :root:not([data-theme]) {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --bg-tertiary: #404040;
        --text-primary: #ffffff;
        --text-secondary: #b0b0b0;
        --text-tertiary: #888888;
        --accent-primary: #4a9eff;
        --accent-secondary: #357abd;
        --accent-success: #2ecc71;
        --accent-warning: #f1c40f;
        --accent-danger: #e67e22;
        --border-primary: #404040;
        --border-secondary: #555555;
        --shadow-light: rgba(0,0,0,0.3);
        --shadow-medium: rgba(0,0,0,0.4);
        --overlay: rgba(255,255,255,0.05);
    }
}

/* Theme transition */
*, *::before, *::after {
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}

/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Georgia', 'Times New Roman', serif;
    line-height: 1.6;
    background-color: var(--bg-primary);
    color: var(--text-primary);
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    text-align: center;
    margin-bottom: 40px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--border-primary);
    position: relative;
}

.main-title {
    font-size: 2.5em;
    color: var(--text-primary);
    margin-bottom: 10px;
}

.subtitle {
    font-size: 1.2em;
    color: var(--text-secondary);
    font-style: italic;
}

/* Theme Toggle Button */
.theme-toggle {
    position: absolute;
    top: 0;
    right: 0;
    background: var(--bg-secondary);
    border: 2px solid var(--border-primary);
    border-radius: 25px;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 1em;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s ease;
}

.theme-toggle:hover {
    background: var(--bg-tertiary);
    transform: scale(1.05);
}

.theme-icon {
    font-size: 1.2em;
}

/* File Upload Area */
.upload-area {
    border: 3px dashed var(--accent-primary);
    border-radius: 12px;
    padding: 60px 40px;
    text-align: center;
    margin-bottom: 30px;
    transition: all 0.3s ease;
    background: var(--bg-secondary);
    cursor: pointer;
}

.upload-area:hover, .upload-area.dragover {
    border-color: var(--accent-secondary);
    background-color: var(--overlay);
    transform: scale(1.02);
}

.upload-icon {
    font-size: 4em;
    color: var(--accent-primary);
    margin-bottom: 20px;
}

.upload-text {
    font-size: 1.3em;
    color: var(--text-primary);
    margin-bottom: 10px;
}

.upload-subtext {
    color: var(--text-secondary);
    font-size: 1em;
}

#fileInput {
    display: none;
}

/* Loading Animation */
.loading {
    display: none;
    text-align: center;
    padding: 40px;
}

.spinner {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Statistics Card */
.stats-card {
    background: var(--bg-secondary);
    padding: 25px;
    border-radius: 12px;
    margin-bottom: 30px;
    box-shadow: 0 4px 12px var(--shadow-light);
    display: none;
    border: 1px solid var(--border-primary);
}

.stats-section {
    background: var(--bg-secondary);
    padding: 25px;
    border-radius: 12px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px var(--shadow-light);
    display: none;
    border: 1px solid var(--border-primary);
}

.stats-title {
    margin-bottom: 20px;
    text-align: center;
    color: var(--text-primary);
    font-weight: 600;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 20px;
    text-align: center;
}

.stat-item {
    padding: 15px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    border: 1px solid var(--border-primary);
}

.stat-number {
    font-size: 2em;
    font-weight: bold;
    color: var(--accent-primary);
    display: block;
}

.stat-label {
    color: var(--text-secondary);
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Controls */
.controls {
    background: var(--bg-secondary);
    padding: 25px;
    border-radius: 12px;
    margin-bottom: 30px;
    box-shadow: 0 4px 12px var(--shadow-light);
    display: none;
    border: 1px solid var(--border-primary);
}

.controls-row {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 20px;
}

.search-box {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid var(--border-primary);
    border-radius: 8px;
    font-size: 1em;
    min-width: 250px;
    background: var(--bg-primary);
    color: var(--text-primary);
}

.search-box:focus {
    outline: none;
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.2);
}

.filter-select {
    padding: 12px 16px;
    border: 2px solid var(--border-primary);
    border-radius: 8px;
    font-size: 1em;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-width: 150px;
}

.btn {
    padding: 12px 20px;
    background: var(--accent-primary);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-block;
}

.btn:hover {
    background: var(--accent-secondary);
    transform: translateY(-1px);
}

.btn-secondary {
    background: var(--text-tertiary);
}

.btn-secondary:hover {
    background: var(--text-secondary);
}

.btn-success {
    background: var(--accent-success);
}

.btn-success:hover {
    background: #219a52;
}

/* Results */
.results {
    display: none;
}

.books-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 25px;
    margin-bottom: 30px;
}

.book-card {
    background: var(--bg-secondary);
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 4px 12px var(--shadow-light);
    transition: transform 0.3s, shadow 0.3s;
    border-left: 5px solid var(--accent-primary);
    cursor: pointer;
    border: 1px solid var(--border-primary);
}

.book-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px var(--shadow-medium);
}

.book-title {
    font-size: 1.3em;
    font-weight: bold;
    color: var(--text-primary);
    margin-bottom: 8px;
    line-height: 1.3;
}

.book-author {
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 15px;
    font-size: 1.1em;
}

.book-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 0.9em;
    color: var(--text-secondary);
}

.book-stat {
    background: var(--bg-tertiary);
    padding: 6px 10px;
    border-radius: 15px;
    font-weight: bold;
    white-space: nowrap;
    font-size: 0.85em;
    color: var(--text-primary);
}

/* Notes View */
.notes-view {
    display: none;
    background: var(--bg-secondary);
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 12px var(--shadow-light);
    border: 1px solid var(--border-primary);
}

.notes-header {
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--border-secondary);
}

.back-btn {
    margin-bottom: 20px;
}

.note {
    background: var(--bg-tertiary);
    margin: 20px 0;
    padding: 25px;
    border-radius: 12px;
    border-left: 5px solid var(--accent-primary);
    transition: box-shadow 0.3s;
    border: 1px solid var(--border-primary);
}

.note:hover {
    box-shadow: 0 4px 12px var(--shadow-light);
}

.note.bookmark {
    border-left-color: var(--accent-danger);
}

.note.note-type {
    border-left-color: var(--accent-warning);
}

.note-meta {
    font-size: 0.9em;
    color: var(--text-secondary);
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.note-type-badge {
    background: var(--accent-primary);
    color: white;
    padding: 4px 10px;
    border-radius: 15px;
    font-size: 0.8em;
    font-weight: bold;
}

.note-type-badge.bookmark {
    background: var(--accent-danger);
}

.note-type-badge.note {
    background: var(--accent-warning);
}

.note-content {
    font-size: 1.1em;
    line-height: 1.7;
    color: var(--text-primary);
}

.empty-note {
    font-style: italic;
    color: var(--text-tertiary);
}

/* Responsive Design */
@media (max-width: 768px) {
    .container {
        padding: 15px;
    }

    .main-title {
        font-size: 2em;
    }

    .upload-area {
        padding: 40px 20px;
    }

    .upload-icon {
        font-size: 3em;
    }

    .controls-row {
        flex-direction: column;
        align-items: stretch;
    }

    .books-grid {
        grid-template-columns: 1fr;
    }

    .note-meta {
        flex-direction: column;
        align-items: flex-start;
    }
}

/* Utility Classes */
.no-results {
    text-align: center;
    padding: 60px 20px;
    color: #7f8c8d;
    font-style: italic;
}

.copy-success {
    background: #27ae60 !important;
    animation: pulse 0.3s ease;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

/* =================================================================== */
/* ACCESSIBILITY STYLES */
/* =================================================================== */

/* Screen reader only content */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Enhanced focus indicators */
.upload-area:focus {
    outline: 3px solid var(--accent-primary);
    outline-offset: 2px;
}

button:focus, .btn:focus {
    outline: 3px solid var(--accent-primary);
    outline-offset: 2px;
}

.theme-toggle:focus {
    outline: 3px solid var(--accent-primary);
    outline-offset: 2px;
    border-radius: 8px;
}

.filter-select:focus {
    outline: 3px solid var(--accent-primary);
    outline-offset: 2px;
}

/* Improve search box focus (enhance existing) */
.search-box:focus {
    outline: none;
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.3);
}

/* Book card focus for keyboard navigation */
.book-card:focus {
    outline: 3px solid var(--accent-primary);
    outline-offset: 2px;
    transform: translateY(-2px);
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    .upload-area:focus,
    button:focus,
    .btn:focus,
    .theme-toggle:focus,
    .filter-select:focus,
    .book-card:focus {
        outline: 4px solid;
        outline-offset: 2px;
    }
    
    .search-box:focus {
        box-shadow: 0 0 0 4px;
    }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .spinner {
        animation: none;
    }
    
    .book-card:hover {
        transform: none;
    }
    
    .upload-area:hover {
        transform: none;
    }
}

/* Ensure minimum touch target size (44px) */
@media (pointer: coarse) {
    button, .btn, .theme-toggle {
        min-height: 44px;
        min-width: 44px;
    }
    
    .upload-area {
        min-height: 100px;
    }
}

/* Color contrast improvements for better readability */
.book-stat {
    border: 1px solid var(--border-primary);
}

.note-type-badge {
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* ==========================================================================
   ERROR HANDLING & NOTIFICATIONS
   ========================================================================== */

/* Error, Warning & Success Notification Styles */
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    max-width: 400px;
    padding: 16px 20px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
    z-index: 1000;
    font-family: var(--font-family);
    font-size: 14px;
    line-height: 1.4;
    transform: translateX(100%);
    opacity: 0;
    transition: all 0.3s ease-in-out;
    border-left: 4px solid;
    display: flex;
    align-items: flex-start;
    gap: 12px;
}

.notification.show {
    transform: translateX(0);
    opacity: 1;
}

/* Error Notification */
.notification.error {
    background: linear-gradient(135deg, 
        rgba(231, 76, 60, 0.1) 0%, 
        rgba(192, 57, 43, 0.05) 100%);
    border-left-color: #e74c3c;
    color: var(--text-primary);
}

.notification.error .notification-icon {
    color: #e74c3c;
    font-size: 18px;
}

/* Warning Notification */
.notification.warning {
    background: linear-gradient(135deg, 
        rgba(243, 156, 18, 0.1) 0%, 
        rgba(230, 126, 34, 0.05) 100%);
    border-left-color: var(--accent-warning);
    color: var(--text-primary);
}

.notification.warning .notification-icon {
    color: var(--accent-warning);
    font-size: 18px;
}

/* Success Notification */
.notification.success {
    background: linear-gradient(135deg, 
        rgba(46, 204, 113, 0.1) 0%, 
        rgba(39, 174, 96, 0.05) 100%);
    border-left-color: #2ecc71;
    color: var(--text-primary);
}

.notification.success .notification-icon {
    color: #2ecc71;
    font-size: 18px;
}

/* Info Notification */
.notification.info {
    background: linear-gradient(135deg, 
        rgba(74, 158, 255, 0.1) 0%, 
        rgba(52, 152, 219, 0.05) 100%);
    border-left-color: var(--accent-primary);
    color: var(--text-primary);
}

.notification.info .notification-icon {
    color: var(--accent-primary);
    font-size: 18px;
}

/* Notification Content */
.notification-content {
    flex: 1;
}

.notification-title {
    font-weight: 600;
    margin: 0 0 4px 0;
    font-size: 15px;
}

.notification-message {
    margin: 0;
    opacity: 0.9;
    font-size: 14px;
}

/* Close Button */
.notification-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    font-size: 18px;
    line-height: 1;
    margin-left: 8px;
    opacity: 0.7;
    transition: all 0.2s ease;
}

.notification-close:hover {
    opacity: 1;
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
}

.notification-close:focus {
    outline: 2px solid var(--accent-primary);
    outline-offset: 1px;
    opacity: 1;
}

/* Loading State with Error Support */
.loading.error {
    background: linear-gradient(135deg, 
        rgba(231, 76, 60, 0.05) 0%, 
        rgba(192, 57, 43, 0.02) 100%);
    border: 1px solid rgba(231, 76, 60, 0.2);
}

.loading.error p {
    color: #e74c3c;
}

/* Enhanced Upload Area Error States */
.upload-area.error {
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.05);
    animation: shake 0.5s ease-in-out;
}

.upload-area.success {
    border-color: #2ecc71;
    background: rgba(46, 204, 113, 0.05);
}

/* Shake animation for error feedback */
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
}

/* Error state for file input */
.upload-area.error .upload-text {
    color: #e74c3c;
}

.upload-area.error .upload-icon {
    color: #e74c3c;
}

/* Accessibility improvements for notifications */
/* Screen readers will announce notifications with role="alert" immediately */

/* Dark theme adjustments for notifications */
:root[data-theme="dark"] .notification {
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

:root[data-theme="dark"] .notification.error {
    background: linear-gradient(135deg, 
        rgba(231, 76, 60, 0.15) 0%, 
        rgba(192, 57, 43, 0.08) 100%);
}

:root[data-theme="dark"] .notification.warning {
    background: linear-gradient(135deg, 
        rgba(243, 156, 18, 0.15) 0%, 
        rgba(230, 126, 34, 0.08) 100%);
}

:root[data-theme="dark"] .notification.success {
    background: linear-gradient(135deg, 
        rgba(46, 204, 113, 0.15) 0%, 
        rgba(39, 174, 96, 0.08) 100%);
}

:root[data-theme="dark"] .notification.info {
    background: linear-gradient(135deg, 
        rgba(74, 158, 255, 0.15) 0%, 
        rgba(52, 152, 219, 0.08) 100%);
}

/* Mobile responsive notifications */
@media (max-width: 768px) {
    .notification {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
        transform: translateY(-100%);
    }
    
    .notification.show {
        transform: translateY(0);
    }
}

/* Reduced motion support for notifications */
@media (prefers-reduced-motion: reduce) {
    .notification {
        transition: none;
    }
    
    .upload-area.error {
        animation: none;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark/light theme">
                <span class="theme-icon" id="themeIcon">🌙</span>
                <span id="themeText">Dark</span>
            </button>
            <h1 class="main-title">📚 Kindle Notes Parser</h1>
            <p class="subtitle">Upload your My Clippings.txt file to organize your highlights and notes</p>
        </div>

        <!-- File Upload Area -->
        <div class="upload-area" 
             id="uploadArea" 
             role="button" 
             tabindex="0"
             aria-label="Upload Kindle notes file"
             aria-describedby="upload-instructions">
            <div class="upload-icon" aria-hidden="true">📁</div>
            <div class="upload-text">Drop your My Clippings.txt file here</div>
            <div class="upload-subtext" id="upload-instructions">
                or click to browse for files. Supports .txt files only.
            </div>
            <input type="file" 
                   id="fileInput" 
                   accept=".txt" 
                   aria-label="Select Kindle notes file" />
        </div>

        <!-- Loading -->
        <div class="loading" id="loading" role="status" aria-live="polite">
            <div class="spinner" aria-hidden="true"></div>
            <p>Parsing your Kindle notes...</p>
        </div>

        <!-- Statistics -->
        <div class="stats-section" id="statsCard" role="region" aria-labelledby="stats-heading">
            <h3 class="stats-title" id="stats-heading">📊 Your Reading Statistics</h3>
            <div class="stats-grid" id="statsGrid" role="list" aria-label="Reading statistics"></div>
        </div>

        <!-- Controls -->
        <div class="controls" id="controls" role="region" aria-label="Search and filter controls">
            <div class="controls-row">
                <input type="text" 
                       class="search-box" 
                       id="searchBox" 
                       placeholder="Search books, authors, or content..."
                       aria-label="Search through your notes"
                       role="searchbox">
                <select class="filter-select" 
                        id="typeFilter"
                        aria-label="Filter by note type">
                    <option value="all">All Types</option>
                    <option value="Highlight">Highlights Only</option>
                    <option value="Bookmark">Bookmarks Only</option>
                    <option value="Note">Notes Only</option>
                </select>
                <button class="btn" 
                        id="exportAllBtn"
                        aria-describedby="export-help">Export All</button>
                <button class="btn btn-secondary" 
                        id="resetBtn"
                        aria-label="Reset and clear all filters">Reset</button>
            </div>
        </div>

        <!-- Results -->
        <div class="results" id="results" role="region" aria-labelledby="results-heading">
            <h2 id="results-heading" class="sr-only">Search Results</h2>
            <div class="books-grid" 
                 id="booksGrid"
                 role="list"
                 aria-label="Books from your Kindle notes">
                <!-- Books will be populated here -->
            </div>
        </div>

        <!-- Notes View -->
        <div class="notes-view" id="notesView" role="main" aria-labelledby="book-title">
            <button class="btn back-btn" 
                    id="backBtn"
                    aria-label="Go back to books list">← Back to Books</button>
            <div class="notes-header" id="notesHeader" role="banner">
                <!-- Book details will be shown here -->
            </div>
            <div id="notesContainer" 
                 role="list"
                 aria-label="Notes and highlights from this book">
                <!-- Notes will be shown here -->
            </div>
        </div>
    </div>

    <script>
/**
 * KindleNote Model
 * Represents a single Kindle note/highlight/bookmark
 */

/**
 * KindleNote Model
 * Represents a single Kindle note/highlight/bookmark
 */

class KindleNote {
    /**
     * Create a new Kindle note
     * @param {string} bookTitle - The title of the book
     * @param {string} author - The author of the book
     * @param {string} noteType - Type of note (Highlight, Bookmark, Note)
     * @param {string} location - Location in the book
     * @param {string|null} page - Page number (if available)
     * @param {Date} dateAdded - When the note was created
     * @param {string} content - The actual note content
     */
    constructor(bookTitle, author, noteType, location, page, dateAdded, content) {
        this.bookTitle = bookTitle;
        this.author = author;
        this.noteType = noteType;
        this.location = location;
        this.page = page;
        this.dateAdded = dateAdded;
        this.content = content;
    }

    /**
     * Get a string representation of the note
     * @returns {string} Formatted note summary
     */
    toString() {
        return `${this.bookTitle} - ${this.noteType} at ${this.location}: ${this.content.substring(0, 50)}...`;
    }
}


/**
 * KindleNotesParser
 * Core parsing logic for Kindle "My Clippings.txt" files
 */

/**
 * KindleNotesParser
 * Core parsing logic for Kindle "My Clippings.txt" files
 */

class KindleNotesParser {
    constructor() {
        this.notes = [];
        this.books = {};
    }

    /**
     * Parse the entire Kindle notes file content
     * @param {string} content - Raw file content
     */
    parseFile(content) {
        const startTime = performance.now();
        console.log(`📊 Processing file size: ${(content.length / 1024).toFixed(1)}KB`);
        
        // Split by the separator
        const entries = content.split('==========');
        
        this.notes = [];
        this.books = {};

        entries.forEach(entry => {
            const trimmedEntry = entry.trim();
            if (!trimmedEntry) return;

            const note = this.parseEntry(trimmedEntry);
            if (note) {
                this.notes.push(note);
                
                if (!this.books[note.bookTitle]) {
                    this.books[note.bookTitle] = [];
                }
                this.books[note.bookTitle].push(note);
            }
        });
        
        const endTime = performance.now();
        const processingTime = endTime - startTime;
        const processingRate = (content.length / 1024) / (processingTime / 1000); // KB/sec
        
        console.log(`⚡ Parsing completed in ${processingTime.toFixed(2)}ms`);
        console.log(`📈 Parsed ${this.notes.length} notes from ${Object.keys(this.books).length} books`);
        console.log(`🚀 Processing rate: ${processingRate.toFixed(1)} KB/sec`);
        console.log(`� Raw entries found: ${entries.length - 1} (${this.notes.length} valid notes)`);
        
        // Performance summary for analytics
        const performanceStats = {
            fileSize: content.length,
            processingTime: processingTime,
            notesCount: this.notes.length,
            booksCount: Object.keys(this.books).length,
            processingRate: processingRate,
            validEntriesRatio: (this.notes.length / (entries.length - 1) * 100).toFixed(1)
        };
        
        // Store performance data for potential future analysis
        window.lastParsingStats = performanceStats;
    }

    /**
     * Parse a single entry from the clippings file
     * @param {string} entry - Single note entry
     * @returns {KindleNote|null} Parsed note or null if invalid
     */
    parseEntry(entry) {
        const lines = entry.split('\n').map(line => line.trim()).filter(line => line);
        
        if (lines.length < 2) {
            return null;
        }

        // Parse book title and author
        const [bookTitle, author] = this.parseTitleAuthor(lines[0]);

        // Parse metadata line
        const [noteType, location, page, dateAdded] = this.parseMetadata(lines[1]);

        // Extract content (everything after the metadata line)
        const content = lines.slice(2).join('\n');

        return new KindleNote(bookTitle, author, noteType, location, page, dateAdded, content);
    }

    /**
     * Parse book title and author from title line
     * @param {string} titleLine - First line of entry
     * @returns {Array} [bookTitle, author]
     */
    parseTitleAuthor(titleLine) {
        // Remove BOM character if present
        titleLine = titleLine.replace(/^\ufeff/, '');

        // Pattern: "Book_Title (Author Name)"
        const match = titleLine.match(/^(.+?)\s*\(([^)]+)\)$/);
        if (match) {
            return [match[1].trim(), match[2].trim()];
        } else {
            // Fallback if pattern doesn't match
            return [titleLine, "Unknown"];
        }
    }

    /**
     * Parse metadata line to extract note information
     * @param {string} metadataLine - Second line of entry
     * @returns {Array} [noteType, location, page, dateAdded]
     */
    parseMetadata(metadataLine) {
        // Default values
        let noteType = "Unknown";
        let location = "";
        let page = null;
        let dateAdded = new Date();

        // Extract note type
        if (metadataLine.includes("Highlight")) {
            noteType = "Highlight";
        } else if (metadataLine.includes("Bookmark")) {
            noteType = "Bookmark";
        } else if (metadataLine.includes("Note")) {
            noteType = "Note";
        }

        // Extract location
        const locationMatch = metadataLine.match(/Location (\d+(?:-\d+)?)/);
        if (locationMatch) {
            location = locationMatch[1];
        }

        // Extract page
        const pageMatch = metadataLine.match(/page (\d+)/);
        if (pageMatch) {
            page = pageMatch[1];
        }

        // Extract date
        const dateMatch = metadataLine.match(/Added on (.+?)$/);
        if (dateMatch) {
            const dateStr = dateMatch[1];
            try {
                // Try different date formats
                dateAdded = new Date(dateStr);
                if (isNaN(dateAdded)) {
                    // Try parsing specific Kindle format
                    const kindleDate = this.parseKindleDate(dateStr);
                    dateAdded = kindleDate || new Date();
                }
            } catch (e) {
                dateAdded = new Date();
            }
        }

        return [noteType, location, page, dateAdded];
    }

    /**
     * Parse Kindle-specific date format
     * @param {string} dateStr - Date string from Kindle
     * @returns {Date|null} Parsed date or null
     */
    parseKindleDate(dateStr) {
        // Handle Kindle date format: "Tuesday, April 1, 2025 4:47:55 PM"
        try {
            return new Date(dateStr);
        } catch (e) {
            return null;
        }
    }

    /**
     * Clean and beautify book title for display
     * @param {string} bookTitle - Raw book title
     * @param {string} author - Book author
     * @returns {string} Cleaned title
     */
    cleanBookTitle(bookTitle, author) {
        let cleanTitle = bookTitle;

        // Remove common prefixes
        cleanTitle = cleanTitle.replace(/^vdoc\.?pub_?/i, '');
        cleanTitle = cleanTitle.replace(/^dokumen\.?pub_?/i, '');

        // Remove long numbers (over 5 digits)
        cleanTitle = cleanTitle.replace(/\b\d{6,}\b/g, '');

        // Replace underscores and hyphens with spaces
        cleanTitle = cleanTitle.replace(/[-_]+/g, ' ');

        // Remove extra whitespace
        cleanTitle = cleanTitle.replace(/\s+/g, ' ').trim();

        // Remove author name from title if it appears at the end
        if (author && author.trim()) {
            const authorWords = author.trim().split(/\s+/);
            
            // Remove full author name
            const authorPattern = new RegExp('\\b' + this.escapeRegex(author.trim()) + '\\b\\s*$', 'i');
            cleanTitle = cleanTitle.replace(authorPattern, '').trim();
            
            // Remove individual author words
            authorWords.forEach(word => {
                if (word.length > 2) {
                    const wordPattern = new RegExp('\\b' + this.escapeRegex(word) + '\\b\\s*$', 'i');
                    cleanTitle = cleanTitle.replace(wordPattern, '').trim();
                }
            });

            // Remove patterns like "(Author Name)"
            cleanTitle = cleanTitle.replace(/\s*\([^)]*\)\s*$/g, '').trim();
        }

        // Clean up common suffixes
        cleanTitle = cleanTitle.replace(/\s*(second edition|first edition|revised|updated)\s*$/i, '');

        // Remove trailing dashes, underscores, or dots
        cleanTitle = cleanTitle.replace(/[-_.]+$/, '').trim();

        // Capitalize properly
        if (cleanTitle) {
            const words = cleanTitle.split(/\s+/);
            const capitalizedWords = words.map((word, index) => {
                const lowerWord = word.toLowerCase();
                if (index === 0 || !['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(lowerWord)) {
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                }
                return lowerWord;
            });
            cleanTitle = capitalizedWords.join(' ');
        }

        return cleanTitle || bookTitle;
    }

    /**
     * Escape regex special characters
     * @param {string} string - String to escape
     * @returns {string} Escaped string
     */
    escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Sort notes by their location numbers
     * @param {Array} notes - Array of notes to sort
     * @returns {Array} Sorted notes
     */
    sortNotesByLocation(notes) {
        return notes.sort((a, b) => {
            const aLocation = this.extractLocationNumber(a.location);
            const bLocation = this.extractLocationNumber(b.location);
            return aLocation - bLocation;
        });
    }

    /**
     * Extract numeric location from location string
     * @param {string} locationStr - Location string
     * @returns {number} Numeric location
     */
    extractLocationNumber(locationStr) {
        if (!locationStr) return 0;
        const match = locationStr.match(/(\d+)/);
        return match ? parseInt(match[1]) : 0;
    }

    /**
     * Get statistics about parsed notes
     * @returns {Object} Statistics object
     */
    getStatistics() {
        return {
            totalNotes: this.notes.length,
            totalBooks: Object.keys(this.books).length,
            highlights: this.notes.filter(n => n.noteType === "Highlight").length,
            bookmarks: this.notes.filter(n => n.noteType === "Bookmark").length,
            notes: this.notes.filter(n => n.noteType === "Note").length
        };
    }

    /**
     * Search notes by query and type
     * @param {string} query - Search query
     * @param {string} typeFilter - Note type filter
     * @returns {Array} Filtered notes
     */
    searchNotes(query, typeFilter = 'all') {
        const lowerQuery = query.toLowerCase();
        return this.notes.filter(note => {
            const matchesQuery = !query || 
                note.content.toLowerCase().includes(lowerQuery) ||
                note.bookTitle.toLowerCase().includes(lowerQuery) ||
                note.author.toLowerCase().includes(lowerQuery);
            
            const matchesType = typeFilter === 'all' || note.noteType === typeFilter;
            
            return matchesQuery && matchesType;
        });
    }

    /**
     * Get books grouped by search criteria
     * @param {string} query - Search query
     * @param {string} typeFilter - Note type filter
     * @returns {Object} Books grouped by title
     */
    getBooksBySearch(query, typeFilter = 'all') {
        const filteredNotes = this.searchNotes(query, typeFilter);
        const bookGroups = {};
        
        filteredNotes.forEach(note => {
            if (!bookGroups[note.bookTitle]) {
                bookGroups[note.bookTitle] = [];
            }
            bookGroups[note.bookTitle].push(note);
        });
        
        return bookGroups;
    }
}


/**
 * Theme Manager
 * Handles light/dark theme detection and switching
 */

/**
 * Theme Manager
 * Handles light/dark theme detection and switching
 */

class ThemeManager {
    constructor() {
        this.themes = {
            light: {
                name: 'light',
                icon: '🌙',
                text: 'Dark'
            },
            dark: {
                name: 'dark', 
                icon: '☀️',
                text: 'Light'
            }
        };

        this.currentTheme = this.detectInitialTheme();
        this.initializeTheme();
        this.setupEventListeners();
    }

    /**
     * Detect initial theme based on user preference or system preference
     */
    detectInitialTheme() {
        // Check if user has previously set a preference
        const savedTheme = localStorage.getItem('kindle-notes-theme');
        if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) {
            return savedTheme;
        }

        // Check system preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }

        // Default to light
        return 'light';
    }

    /**
     * Initialize theme on page load
     */
    initializeTheme() {
        this.applyTheme(this.currentTheme);
        this.updateThemeToggle();

        // Listen for system theme changes
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Only auto-switch if user hasn't manually set a preference
                const savedTheme = localStorage.getItem('kindle-notes-theme');
                if (!savedTheme) {
                    const newTheme = e.matches ? 'dark' : 'light';
                    this.setTheme(newTheme);
                }
            });
        }
    }

    /**
     * Apply theme to document
     */
    applyTheme(theme) {
        const html = document.documentElement;
        
        if (theme === 'dark') {
            html.setAttribute('data-theme', 'dark');
        } else if (theme === 'light') {
            html.setAttribute('data-theme', 'light');
        } else {
            // Fallback: remove attribute to use system preference
            html.removeAttribute('data-theme');
        }

        this.currentTheme = theme;
    }

    /**
     * Update theme toggle button appearance
     */
    updateThemeToggle() {
        const themeIcon = document.getElementById('themeIcon');
        const themeText = document.getElementById('themeText');
        
        if (themeIcon && themeText) {
            const nextTheme = this.currentTheme === 'light' ? 'dark' : 'light';
            themeIcon.textContent = this.themes[this.currentTheme].icon;
            themeText.textContent = this.themes[this.currentTheme].text;
        }
    }

    /**
     * Set theme and save preference
     */
    setTheme(theme) {
        this.applyTheme(theme);
        this.updateThemeToggle();
        localStorage.setItem('kindle-notes-theme', theme);

        // Dispatch custom event for other components to listen to
        window.dispatchEvent(new CustomEvent('themeChanged', {
            detail: { theme: theme }
        }));
    }

    /**
     * Toggle between themes
     */
    toggleTheme() {
        const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';
        this.setTheme(newTheme);
        
        // Add a subtle animation feedback
        const toggle = document.getElementById('themeToggle');
        if (toggle) {
            toggle.style.transform = 'scale(0.95)';
            setTimeout(() => {
                toggle.style.transform = '';
            }, 150);
        }
    }

    /**
     * Setup event listeners
     */
    setupEventListeners() {
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => this.toggleTheme());
            
            // Keyboard support
            themeToggle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.toggleTheme();
                }
            });
        }

        // Listen for theme changes from other sources
        window.addEventListener('themeChanged', (e) => {
            console.log(`🎨 Theme changed to: ${e.detail.theme}`);
        });
    }

    /**
     * Get current theme
     */
    getCurrentTheme() {
        return this.currentTheme;
    }

    /**
     * Check if current theme is dark
     */
    isDarkTheme() {
        return this.currentTheme === 'dark';
    }

    /**
     * Get theme-appropriate color for dynamic content
     */
    getThemeColors() {
        return {
            primary: this.isDarkTheme() ? '#4a9eff' : '#3498db',
            secondary: this.isDarkTheme() ? '#e0e0e0' : '#333333',
            background: this.isDarkTheme() ? '#2d2d2d' : '#ffffff',
            text: this.isDarkTheme() ? '#e0e0e0' : '#333333'
        };
    }
}


/**
 * KindleNotesApp
 * Main application class that handles UI interactions and file processing
 */

/**
 * KindleNotesApp
 * Main application class that handles UI interactions and file processing
 */

class KindleNotesApp {
    constructor() {
        this.parser = new KindleNotesParser();
        this.initializeEventListeners();
    }

    /**
     * Initialize all event listeners for the application
     */
    initializeEventListeners() {
        // File upload events
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        
        // Keyboard support for upload area
        uploadArea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                fileInput.click();
            }
        });
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
            uploadArea.setAttribute('aria-label', 'Drop file here to upload');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
            uploadArea.setAttribute('aria-label', 'Upload Kindle notes file');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            uploadArea.setAttribute('aria-label', 'Upload Kindle notes file');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleFile(e.target.files[0]);
            }
        });

        // Search and filter events
        document.getElementById('searchBox').addEventListener('input', (e) => {
            this.filterBooks(e.target.value, document.getElementById('typeFilter').value);
        });

        document.getElementById('typeFilter').addEventListener('change', (e) => {
            this.filterBooks(document.getElementById('searchBox').value, e.target.value);
        });

        // Button events
        document.getElementById('backBtn').addEventListener('click', () => {
            this.showBooksView();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            this.reset();
        });

        document.getElementById('exportAllBtn').addEventListener('click', () => {
            this.exportAllHighlights();
        });
    }

    /**
     * Validate file before processing
     * @param {File} file - File to validate
     * @returns {Object} Validation result {valid: boolean, error?: string, title?: string}
     */
    validateFile(file) {
        // Check if file exists
        if (!file) {
            return {
                valid: false,
                error: 'No file was selected. Please choose a file to upload.',
                title: 'No File Selected'
            };
        }

        // File type validation (more comprehensive)
        const fileName = file.name.toLowerCase();
        const allowedExtensions = ['.txt'];
        const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
        
        if (!hasValidExtension) {
            return {
                valid: false,
                error: `Invalid file type. Please select a .txt file. Your file: "${file.name}"`,
                title: 'Invalid File Type'
            };
        }

        // File size validation (50MB limit)
        const maxSize = 50 * 1024 * 1024; // 50MB in bytes
        if (file.size > maxSize) {
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(1);
            return {
                valid: false,
                error: `File too large (${fileSizeMB}MB). Maximum file size is 50MB. Please try with a smaller file.`,
                title: 'File Size Limit Exceeded'
            };
        }

        // Minimum file size check (empty file detection)
        if (file.size === 0) {
            return {
                valid: false,
                error: 'The selected file is empty. Please choose a file that contains Kindle notes.',
                title: 'Empty File'
            };
        }

        // Very small file warning (likely not a proper Kindle notes file)
        if (file.size < 100) { // Less than 100 bytes
            return {
                valid: false,
                error: 'This file appears to be too small to contain Kindle notes. A typical My Clippings.txt file should be at least a few hundred bytes.',
                title: 'File Too Small'
            };
        }

        return { valid: true };
    }

    /**
     * Validate file content format
     * @param {string} content - File content to validate
     * @returns {Object} Validation result {valid: boolean, error?: string, title?: string, warning?: string}
     */
    validateContent(content) {
        // Check if content exists and is not just whitespace
        if (!content || content.trim().length === 0) {
            return {
                valid: false,
                error: 'The file appears to be empty or contains only whitespace. Please check that your My Clippings.txt file contains notes.',
                title: 'Empty File Content'
            };
        }

        // Check for proper Kindle format (contains separators)
        const separators = content.match(/==========/g);
        if (!separators || separators.length === 0) {
            return {
                valid: false,
                error: 'This file does not appear to be a valid Kindle My Clippings.txt file. Kindle notes should be separated by "==========" lines.',
                title: 'Invalid File Format'
            };
        }

        // Check for reasonable content structure
        const lines = content.split('\n').filter(line => line.trim().length > 0);
        if (lines.length < 3) {
            return {
                valid: false,
                error: 'This file does not contain enough content to be a valid Kindle notes file. Each note should have at least a title, metadata, and content.',
                title: 'Insufficient Content'
            };
        }

        // Look for typical Kindle patterns
        const hasKindlePatterns = /- Your (Highlight|Note|Bookmark) on/i.test(content) ||
                                /Added on \w+day,/i.test(content) ||
                                /Location \d+/i.test(content);

        if (!hasKindlePatterns) {
            return {
                valid: true,
                warning: 'This file may not be in the standard Kindle format, but we\'ll try to parse it. If you get unexpected results, please ensure you\'re using the My Clippings.txt file from your Kindle device.'
            };
        }

        return { valid: true };
    }

    /**
     * Handle file upload and processing with comprehensive error handling
     * @param {File} file - Selected file
     */
    async handleFile(file) {
        const totalStartTime = performance.now();
        
        // Clear any existing notifications
        this.clearNotifications();
        
        // Log file info for debugging
        if (file) {
            console.log(`📁 Processing file: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`);
        }

        // Step 1: File validation
        const fileValidation = this.validateFile(file);
        if (!fileValidation.valid) {
            this.showError(fileValidation.error, fileValidation.title);
            return;
        }

        // Show loading state
        this.showLoading();

        try {
            // Step 2: Read file content
            const readStartTime = performance.now();
            const content = await this.readFile(file);
            const readTime = performance.now() - readStartTime;
            console.log(`📖 File read in ${readTime.toFixed(2)}ms`);

            // Step 3: Content validation
            const contentValidation = this.validateContent(content);
            if (!contentValidation.valid) {
                this.hideLoading();
                this.showError(contentValidation.error, contentValidation.title);
                return;
            }

            // Show warning if content format is questionable
            if (contentValidation.warning) {
                this.showWarning(contentValidation.warning, 'Format Warning');
            }

            // Step 4: Parse the content
            const parseStartTime = performance.now();
            this.parser.parseFile(content);
            const parseTime = performance.now() - parseStartTime;
            console.log(`⚡ Parsing completed in ${parseTime.toFixed(2)}ms`);

            // Step 5: Validate parsing results
            if (this.parser.notes.length === 0) {
                this.hideLoading();
                this.showError(
                    'No valid Kindle notes were found in this file. Please ensure you\'re using the correct "My Clippings.txt" file from your Kindle device. The file should contain highlights, notes, or bookmarks separated by "==========" lines.',
                    'No Notes Found'
                );
                
                // Provide helpful guidance
                setTimeout(() => {
                    this.showInfo(
                        'To export your notes: Connect your Kindle to your computer, navigate to the "documents" folder, and copy the "My Clippings.txt" file.',
                        'How to Get Your Notes',
                        10000
                    );
                }, 1000);
                return;
            }

            // Step 6: Display results
            const displayStartTime = performance.now();
            this.displayResults();
            const displayTime = performance.now() - displayStartTime;
            console.log(`🎨 UI rendered in ${displayTime.toFixed(2)}ms`);

            // Step 7: Success notification and performance logging
            const totalTime = performance.now() - totalStartTime;
            const stats = this.parser.getStatistics();
            
            this.showSuccess(
                `Successfully parsed ${stats.totalNotes} notes from ${stats.totalBooks} books! Found ${stats.highlights} highlights, ${stats.notes} notes, and ${stats.bookmarks} bookmarks.`,
                'File Processed Successfully'
            );

            // Performance logging
            console.log(`🏁 Total processing time: ${totalTime.toFixed(2)}ms`);
            console.log(`📊 Performance breakdown: Read(${((readTime/totalTime)*100).toFixed(1)}%) + Parse(${((parseTime/totalTime)*100).toFixed(1)}%) + Display(${((displayTime/totalTime)*100).toFixed(1)}%)`);
            
            // Update page title for accessibility
            this.updatePageTitle(`Kindle Notes Parser - ${stats.totalBooks} Books Loaded`);

        } catch (error) {
            this.hideLoading();
            console.error('❌ File processing failed:', error);
            
            // Enhanced error handling with specific error types
            if (error.name === 'NotReadableError' || error.message.includes('read')) {
                this.showError(
                    'Unable to read the selected file. The file might be corrupted or in use by another application.',
                    'File Reading Error'
                );
            } else if (error.name === 'SecurityError') {
                this.showError(
                    'Security restrictions prevent reading this file. Please try selecting the file again.',
                    'Security Error'
                );
            } else if (error.name === 'AbortError') {
                this.showWarning('File reading was cancelled.', 'Operation Cancelled');
            } else {
                // Generic error with helpful suggestions
                this.showError(
                    `An unexpected error occurred while processing your file: ${error.message}. Please try again, or contact support if the problem persists.`,
                    'Processing Error'
                );
            }

            // Provide recovery suggestions
            setTimeout(() => {
                this.showInfo(
                    'Try these steps: 1) Ensure the file is not open in another program, 2) Check that the file is a valid .txt file, 3) Try with a smaller file to test.',
                    'Troubleshooting Tips',
                    8000
                );
            }, 2000);
        }
    }

    /**
     * Read file content as text with enhanced error handling
     * @param {File} file - File to read
     * @returns {Promise<string>} File content
     */
    readFile(file) {
        return new Promise((resolve, reject) => {
            // Validate file parameter
            if (!file) {
                reject(new Error('No file provided for reading'));
                return;
            }

            const reader = new FileReader();
            
            // Set up event handlers
            reader.onload = (e) => {
                const content = e.target.result;
                
                // Validate that we got content
                if (content === null || content === undefined) {
                    reject(new Error('File content is empty or unreadable'));
                    return;
                }
                
                resolve(content);
            };

            reader.onerror = (e) => {
                // Provide more specific error messages based on the error
                const error = e.target.error;
                let errorMessage = 'Failed to read file';
                
                if (error) {
                    switch (error.name) {
                        case 'NotReadableError':
                            errorMessage = 'The file could not be read. It may be corrupted or locked by another application.';
                            break;
                        case 'SecurityError':
                            errorMessage = 'Access to the file was denied for security reasons.';
                            break;
                        case 'NotFoundError':
                            errorMessage = 'The file could not be found.';
                            break;
                        case 'AbortError':
                            errorMessage = 'File reading was aborted.';
                            break;
                        default:
                            errorMessage = `File reading failed: ${error.message || 'Unknown error'}`;
                    }
                }
                
                reject(new Error(errorMessage));
            };

            reader.onabort = () => {
                reject(new Error('File reading was cancelled'));
            };

            // Set timeout for large files (30 second timeout)
            const timeout = setTimeout(() => {
                reader.abort();
                reject(new Error('File reading timed out. The file may be too large or corrupted.'));
            }, 30000);

            // Clear timeout on success or error
            const originalOnload = reader.onload;
            const originalOnerror = reader.onerror;
            
            reader.onload = (e) => {
                clearTimeout(timeout);
                originalOnload(e);
            };
            
            reader.onerror = (e) => {
                clearTimeout(timeout);
                originalOnerror(e);
            };

            // Start reading the file as UTF-8 text
            try {
                reader.readAsText(file, 'UTF-8');
            } catch (error) {
                clearTimeout(timeout);
                reject(new Error(`Failed to start reading file: ${error.message}`));
            }
        });
    }

    /**
     * Show loading state
     */
    showLoading() {
        document.getElementById('uploadArea').style.display = 'none';
        document.getElementById('loading').style.display = 'block';
        this.hideResults();
    }

    /**
     * Hide loading state
     */
    hideLoading() {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('uploadArea').style.display = 'block';
    }

    /**
     * Display parsed results
     */
    displayResults() {
        this.hideLoading();
        this.displayStatistics();
        this.displayBooks();
        this.showResults();
        
        // Announce results to screen readers
        const stats = this.parser.getStatistics();
        this.announceToScreenReader(`Processing complete. Found ${stats.totalNotes} notes from ${stats.totalBooks} books.`);
    }

    /**
     * Display statistics dashboard
     */
    displayStatistics() {
        const statsStartTime = performance.now();
        const stats = this.parser.getStatistics();
        const statsGrid = document.getElementById('statsGrid');
        
        statsGrid.innerHTML = `
            <div class="stat-item" role="listitem" aria-label="${stats.totalNotes} total notes">
                <span class="stat-number" aria-hidden="true">${stats.totalNotes}</span>
                <span class="stat-label" aria-hidden="true">Total Notes</span>
            </div>
            <div class="stat-item" role="listitem" aria-label="${stats.totalBooks} books">
                <span class="stat-number" aria-hidden="true">${stats.totalBooks}</span>
                <span class="stat-label" aria-hidden="true">Books</span>
            </div>
            <div class="stat-item" role="listitem" aria-label="${stats.highlights} highlights">
                <span class="stat-number" aria-hidden="true">${stats.highlights}</span>
                <span class="stat-label" aria-hidden="true">Highlights</span>
            </div>
            <div class="stat-item" role="listitem" aria-label="${stats.bookmarks} bookmarks">
                <span class="stat-number" aria-hidden="true">${stats.bookmarks}</span>
                <span class="stat-label" aria-hidden="true">Bookmarks</span>
            </div>
            <div class="stat-item" role="listitem" aria-label="${stats.notes} notes">
                <span class="stat-number" aria-hidden="true">${stats.notes}</span>
                <span class="stat-label" aria-hidden="true">Notes</span>
            </div>
        `;

        document.getElementById('statsCard').style.display = 'block';
        const statsTime = performance.now() - statsStartTime;
        console.log(`📊 Statistics rendered in ${statsTime.toFixed(2)}ms`);
    }

    /**
     * Display books grid
     * @param {Object} booksToShow - Books to display (optional)
     */
    displayBooks(booksToShow = null) {
        const booksStartTime = performance.now();
        const books = booksToShow || this.parser.books;
        const booksGrid = document.getElementById('booksGrid');

        if (Object.keys(books).length === 0) {
            booksGrid.innerHTML = '<div class="no-results">No books found matching your search criteria.</div>';
            return;
        }

        // Sort books by note count (descending)
        const sortedBooks = Object.entries(books).sort((a, b) => b[1].length - a[1].length);

        booksGrid.innerHTML = sortedBooks.map(([title, notes]) => {
            const author = notes[0].author;
            const cleanTitle = this.parser.cleanBookTitle(title, author);
            const highlightCount = notes.filter(n => n.noteType === 'Highlight').length;
            const bookmarkCount = notes.filter(n => n.noteType === 'Bookmark').length;
            const noteCount = notes.filter(n => n.noteType === 'Note').length;

            return `
                <div class="book-card" 
                     role="listitem"
                     tabindex="0"
                     onclick="app.showBookNotes('${this.escapeHtml(title)}')"
                     onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();app.showBookNotes('${this.escapeHtml(title)}');}"
                     aria-label="View notes for ${this.escapeHtml(cleanTitle)} by ${this.escapeHtml(author)}, ${notes.length} notes total">
                    <div class="book-title">${this.escapeHtml(cleanTitle)}</div>
                    <div class="book-author">by ${this.escapeHtml(author)}</div>
                    <div class="book-stats">
                        <span class="book-stat" role="text">${notes.length} total</span>
                        <span class="book-stat" role="text">${highlightCount} highlights</span>
                        <span class="book-stat" role="text">${bookmarkCount} bookmarks</span>
                        <span class="book-stat" role="text">${noteCount} notes</span>
                    </div>
                </div>
            `;
        }).join('');
        
        const booksTime = performance.now() - booksStartTime;
        console.log(`📚 Books grid rendered in ${booksTime.toFixed(2)}ms (${Object.keys(books).length} books)`);
    }

    /**
     * Show detailed notes view for a specific book
     * @param {string} bookTitle - Title of the book
     */
    showBookNotes(bookTitle) {
        const notes = this.parser.books[bookTitle];
        if (!notes) return;

        const sortedNotes = this.parser.sortNotesByLocation(notes);
        const author = notes[0].author;
        const cleanTitle = this.parser.cleanBookTitle(bookTitle, author);

        // Update header
        const notesHeader = document.getElementById('notesHeader');
        notesHeader.innerHTML = `
            <h2 class="book-title" id="book-title">${this.escapeHtml(cleanTitle)}</h2>
            <p class="book-author">by ${this.escapeHtml(author)}</p>
            <div class="book-stats">
                <span class="book-stat">${notes.length} notes • Sorted by location</span>
            </div>
            <button class="btn btn-success" 
                    onclick="app.copyBookHighlights('${this.escapeHtml(bookTitle)}')"
                    aria-label="Copy all highlights from ${this.escapeHtml(cleanTitle)}">
                📋 Copy All Highlights
            </button>
        `;
        
        // Update page title and announce to screen readers
        this.updatePageTitle(`${cleanTitle} - Kindle Notes Parser`);
        this.announceToScreenReader(`Viewing ${notes.length} notes from ${cleanTitle} by ${author}`);

        // Display notes
        const notesContainer = document.getElementById('notesContainer');
        notesContainer.innerHTML = sortedNotes.map((note, index) => {
            const noteClass = note.noteType.toLowerCase();
            const content = note.content.trim() || '[No content]';
            const isEmpty = !note.content.trim();
            const formattedDate = note.dateAdded.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            return `
                <div class="note ${noteClass}" 
                     role="listitem" 
                     aria-labelledby="note-heading-${index}"
                     tabindex="0">
                    <div class="note-meta">
                        <div>
                            <span class="note-type-badge ${noteClass}" aria-label="${note.noteType} note">${note.noteType}</span>
                            <span style="margin-left: 10px; font-weight: bold; color: var(--accent-primary);">Location ${note.location}</span>
                        </div>
                        <span style="font-style: italic;" aria-label="Added on ${formattedDate}">${formattedDate}</span>
                    </div>
                    <div id="note-heading-${index}" class="sr-only">
                        ${note.noteType} at location ${note.location} from ${formattedDate}
                    </div>
                    <div class="note-content ${isEmpty ? 'empty-note' : ''}" role="text">
                        ${this.escapeHtml(content)}
                    </div>
                </div>
            `;
        }).join('');

        this.showNotesView();
    }

    /**
     * Filter books by search query and type
     * @param {string} query - Search query
     * @param {string} typeFilter - Type filter
     */
    filterBooks(query, typeFilter) {
        const filteredBooks = this.parser.getBooksBySearch(query, typeFilter);
        this.displayBooks(filteredBooks);
    }

    /**
     * Copy all highlights from a book to clipboard
     * @param {string} bookTitle - Title of the book
     */
    copyBookHighlights(bookTitle) {
        const notes = this.parser.books[bookTitle];
        const highlights = notes.filter(n => n.noteType === 'Highlight' && n.content.trim());
        const highlightsText = highlights.map(n => n.content.trim()).join('\n\n');

        if (!highlightsText) {
            this.showWarning(
                `No highlights were found in "${bookTitle}". This book may only contain notes or bookmarks.`,
                'No Highlights Available'
            );
            return;
        }

        this.copyToClipboard(highlightsText).then(() => {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '✅ Copied to Clipboard!';
            btn.classList.add('copy-success');
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove('copy-success');
            }, 2000);
        }).catch((error) => {
            console.error('Clipboard copy failed:', error);
            this.showError(
                'Could not copy to clipboard. This may be due to browser security restrictions. Please manually select and copy the text.',
                'Clipboard Error'
            );
        });
    }

    /**
     * Export all highlights to a downloadable file
     */
    exportAllHighlights() {
        const allHighlights = this.parser.notes
            .filter(n => n.noteType === 'Highlight' && n.content.trim())
            .map(n => `${this.parser.cleanBookTitle(n.bookTitle, n.author)}\n${n.content.trim()}`)
            .join('\n\n---\n\n');

        if (!allHighlights) {
            this.showWarning(
                'No highlights were found in your notes. Your file may contain only notes and bookmarks, which are not included in the highlights export.',
                'No Highlights to Export'
            );
            return;
        }

        this.downloadTextFile('all_kindle_highlights.txt', allHighlights);
        
        // Show success notification
        const highlightCount = this.parser.notes.filter(n => n.noteType === 'Highlight' && n.content.trim()).length;
        this.showSuccess(
            `Successfully exported ${highlightCount} highlights to "all_kindle_highlights.txt"`,
            'Export Complete'
        );
    }

    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     * @returns {Promise} Copy promise
     */
    async copyToClipboard(text) {
        if (navigator.clipboard) {
            return navigator.clipboard.writeText(text);
        } else {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            return Promise.resolve();
        }
    }

    /**
     * Download text as file
     * @param {string} filename - File name
     * @param {string} content - File content
     */
    downloadTextFile(filename, content) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }

    /**
     * Show results view
     */
    showResults() {
        document.getElementById('controls').style.display = 'block';
        document.getElementById('results').style.display = 'block';
        document.getElementById('notesView').style.display = 'none';
        
        // Reset page title when showing main results
        this.updatePageTitle('Kindle Notes Parser - Web App');
    }

    /**
     * Show books view
     */
    showBooksView() {
        document.getElementById('results').style.display = 'block';
        document.getElementById('notesView').style.display = 'none';
    }

    /**
     * Show notes view
     */
    showNotesView() {
        document.getElementById('results').style.display = 'none';
        document.getElementById('notesView').style.display = 'block';
    }

    /**
     * Hide all result views
     */
    hideResults() {
        document.getElementById('statsCard').style.display = 'none';
        document.getElementById('controls').style.display = 'none';
        document.getElementById('results').style.display = 'none';
        document.getElementById('notesView').style.display = 'none';
    }

    /**
     * Reset application to initial state
     */
    reset() {
        this.hideResults();
        document.getElementById('uploadArea').style.display = 'block';
        document.getElementById('searchBox').value = '';
        document.getElementById('typeFilter').value = 'all';
        document.getElementById('fileInput').value = '';
    }

    /**
     * Get performance summary for the current session
     * @returns {Object} Performance statistics
     */
    getPerformanceSummary() {
        if (window.lastParsingStats) {
            return {
                ...window.lastParsingStats,
                timestamp: new Date().toISOString(),
                averageNotesPerBook: (window.lastParsingStats.notesCount / window.lastParsingStats.booksCount).toFixed(1),
                memoryEstimate: `${(window.lastParsingStats.fileSize / 1024 / 1024).toFixed(2)}MB processed`
            };
        }
        return null;
    }

    /**
     * Log performance summary to console
     */
    logPerformanceSummary() {
        const summary = this.getPerformanceSummary();
        if (summary) {
            console.log('📋 Performance Summary:');
            console.table(summary);
        }
    }

    /**
     * Announce message to screen readers using live region
     * @param {string} message - Message to announce
     * @param {string} priority - 'polite' or 'assertive'
     */
    announceToScreenReader(message, priority = 'polite') {
        // Create or update live region
        let liveRegion = document.getElementById('live-region');
        if (!liveRegion) {
            liveRegion = document.createElement('div');
            liveRegion.id = 'live-region';
            liveRegion.setAttribute('aria-live', priority);
            liveRegion.setAttribute('aria-atomic', 'true');
            liveRegion.className = 'sr-only';
            document.body.appendChild(liveRegion);
        }
        
        // Clear and set new message
        liveRegion.textContent = '';
        setTimeout(() => {
            liveRegion.textContent = message;
        }, 100);
    }

    /**
     * Update page title for screen readers and browser tab
     * @param {string} title - New page title
     */
    updatePageTitle(title) {
        document.title = title;
    }

    /**
     * Show error notification with enhanced UX
     * @param {string} message - Error message to display
     * @param {string} title - Error title (optional)
     * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
     */
    showError(message, title = 'Error', duration = 8000) {
        this.showNotification('error', '❌', title, message, duration);
        this.announceToScreenReader(`Error: ${title}. ${message}`, 'assertive');
        
        // Add error state to upload area briefly
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) {
            uploadArea.classList.add('error');
            setTimeout(() => uploadArea.classList.remove('error'), 3000);
        }
    }

    /**
     * Show warning notification
     * @param {string} message - Warning message to display
     * @param {string} title - Warning title (optional)
     * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
     */
    showWarning(message, title = 'Warning', duration = 6000) {
        this.showNotification('warning', '⚠️', title, message, duration);
        this.announceToScreenReader(`Warning: ${title}. ${message}`, 'polite');
    }

    /**
     * Show success notification
     * @param {string} message - Success message to display  
     * @param {string} title - Success title (optional)
     * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
     */
    showSuccess(message, title = 'Success', duration = 4000) {
        this.showNotification('success', '✅', title, message, duration);
        this.announceToScreenReader(`Success: ${title}. ${message}`, 'polite');
        
        // Add success state to upload area briefly
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) {
            uploadArea.classList.add('success');
            setTimeout(() => uploadArea.classList.remove('success'), 2000);
        }
    }

    /**
     * Show info notification
     * @param {string} message - Info message to display
     * @param {string} title - Info title (optional)
     * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
     */
    showInfo(message, title = 'Info', duration = 5000) {
        this.showNotification('info', 'ℹ️', title, message, duration);
        this.announceToScreenReader(`${title}. ${message}`, 'polite');
    }

    /**
     * Create and show a notification
     * @param {string} type - Notification type (error, warning, success, info)
     * @param {string} icon - Icon to display
     * @param {string} title - Notification title
     * @param {string} message - Notification message
     * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
     */
    showNotification(type, icon, title, message, duration = 5000) {
        // Remove any existing notifications of the same type
        const existingNotifications = document.querySelectorAll(`.notification.${type}`);
        existingNotifications.forEach(notification => notification.remove());

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.setAttribute('role', 'alert');
        notification.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');

        // Create notification content
        notification.innerHTML = `
            <div class="notification-icon" aria-hidden="true">${icon}</div>
            <div class="notification-content">
                <div class="notification-title">${this.escapeHtml(title)}</div>
                <div class="notification-message">${this.escapeHtml(message)}</div>
            </div>
            <button class="notification-close" aria-label="Dismiss notification" type="button">×</button>
        `;

        // Add to DOM
        document.body.appendChild(notification);

        // Show animation
        requestAnimationFrame(() => {
            notification.classList.add('show');
        });

        // Set up close button
        const closeBtn = notification.querySelector('.notification-close');
        const closeNotification = () => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        };

        closeBtn.addEventListener('click', closeNotification);

        // Auto-dismiss if duration is set
        if (duration > 0) {
            setTimeout(() => {
                if (notification.classList.contains('show')) {
                    closeNotification();
                }
            }, duration);
        }

        // Keyboard support
        closeBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                closeNotification();
            }
        });

        return notification;
    }

    /**
     * Clear all notifications
     */
    clearNotifications() {
        const notifications = document.querySelectorAll('.notification');
        notifications.forEach(notification => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        });
    }

    /**
     * Handle and format error objects with detailed information
     * @param {Error|string} error - Error object or message
     * @param {string} context - Context where error occurred
     */
    handleError(error, context = 'Unknown') {
        console.error(`❌ Error in ${context}:`, error);
        
        let message = 'An unexpected error occurred.';
        let title = 'Error';
        
        if (typeof error === 'string') {
            message = error;
        } else if (error instanceof Error) {
            message = error.message;
            
            // Provide more specific error titles based on error type
            if (error.name === 'TypeError') {
                title = 'Type Error';
            } else if (error.name === 'ReferenceError') {
                title = 'Reference Error';
            } else if (error.name === 'SyntaxError') {
                title = 'Syntax Error';
            } else {
                title = error.name || 'Error';
            }
        }
        
        this.showError(message, title);
    }

    /**
     * Escape HTML characters in text
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}


/**
 * Main Application Initialization
 * Entry point for the Kindle Notes Parser web application
 */

/**
 * Main Application Initialization
 * Entry point for the Kindle Notes Parser web application
 */

// Initialize the application when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Kindle Notes Parser - Initializing...');
    
    // Initialize theme manager first
    window.themeManager = new ThemeManager();
    console.log(`🎨 Theme initialized: ${window.themeManager.getCurrentTheme()}`);
    
    // Create and start the app
    window.app = new KindleNotesApp();
    
    console.log('✅ Application ready! Upload your My Clippings.txt file to get started.');
});
    </script>
</body>
</html>